import shost.config (Config)
import shost.http
import std.env
import std.optparse (Options)
import std.stdio (Stderr, Stdout)
import std.string (ToString)
import std.sys (exit)

let VERSION = '0.4.0'

fn print[T: ToString](value: ref T) {
  Stdout.new.print(value.to_string)
}

fn error(value: String) -> Never {
  let out = Stderr.new
  let _ = out.print(
    if out.terminal? {
      '\e[31;1merror\e[0m: ${value}'
    } else {
      'error: ${value}'
    },
  )

  exit(1)
}

fn run(arguments: Array[String]) -> Result[Nil, String] {
  let opts = Options.new('shost')

  opts.description = 'An HTTP server for self-hosting static websites.'
  opts.usage = '[OPTIONS]'

  opts.flag('h', 'help', 'Show this help message')
  opts.single('s', 'sites', 'DIR', 'The directory containing websites to serve')
  opts.single('t', 'tls', 'DIR', 'The directory containing TLS configuration')
  opts.single('p', 'port', 'PORT', 'The port to listen on')
  opts.single('i', 'ip', 'IP', 'The IP to bind to')
  opts.flag('q', 'quiet', 'Disables logging of requests')
  opts.flag('', 'no-timestamps', "Don't add timestamps to log entries")
  opts.flag('v', 'version', 'Show the version')

  let matches = try opts.parse(arguments).map_error(fn (e) { e.to_string })

  if matches.contains?('help') {
    print(opts)
    return Result.Ok(nil)
  }

  if matches.contains?('version') {
    print('shost ${VERSION}')
    return Result.Ok(nil)
  }

  let cfg = Config.new

  match matches.value('sites') {
    case Some(v) -> cfg.sites = v.to_path
    case _ -> {}
  }

  match matches.value('tls') {
    case Some(v) -> cfg.tls = v.to_path
    case _ -> {}
  }

  match matches.value('ip') {
    case Some(v) -> try cfg.parse_ip(v)
    case _ -> {}
  }

  match matches.value('port') {
    case Some(v) -> try cfg.parse_port(v)
    case _ -> {}
  }

  cfg.log_requests = !matches.contains?('quiet')
  cfg.log_timestamps = !matches.contains?('no-timestamps')

  http.start(cfg)
}

type async Main {
  fn async main {
    match run(env.arguments) {
      case Ok(_) -> {}
      case Error(e) -> error(e)
    }
  }
}
