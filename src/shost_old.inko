import std.bytes (Slice)
import std.env
import std.fs.path (Path)
import std.int
import std.net.http (Header, Status)
import std.net.http.server (
  Directory, Get, Handle, Head, Logger, Request, Response, Server,
  compress_response,
)
import std.net.tls (ServerConfig)
import std.optparse (Options)
import std.signal (Signal)
import std.stdio (Stderr, Stdout)
import std.sync (AtomicInt, Promise)
import std.sys

let pub SITES = '/var/lib/wobsite'
let pub PORT = 443

fn error(value: String) -> Never {
  let _ = Stderr.new.print('error: ${value}')

  sys.exit(1)
}

fn expand(path: Path) -> Result[Path, String] {
  path.expand.map_error(fn (e) { "the directory '${path}' must exist" })
}

fn load_tls(path: ref Path) -> Result[Map[String, ServerConfig], String] {
  let map = Map.new

  for
    entry
  in
    try path.list.map_error(fn (e) {
      'failed to get the contents of the TLS directory: ${e}'
    })
  {
    let Ok({ @path = path, @type = Directory }) = entry else next
    let cert = path.join('cert.pem')
    let key = path.join('key.pem')

    if !cert.file? or !key.file? { next }

    let conf = match ServerConfig.builder.from_files(cert, key) {
      case Ok(v) -> v
      case Error(e) -> {
        throw 'failed to parse the TLS configuration for ${path}: ${e}'
      }
    }

    map.set(path.tail.to_string, conf)
  }

  Result.Ok(map)
}

fn load_sites(path: ref Path) -> Result[Map[Slice[String], Directory], String] {
  let map = Map.new

  for
    entry
  in
    try path.list.map_error(fn (e) {
      'failed to get the contents of the sites directory: ${e}'
    })
  {
    let Ok({ @path = path, @type = Directory }) = entry else next

    # For the key we use a Slice of a new String so we don't have to keep the
    # whole file path around.
    map.set(path.tail.to_string.to_slice, Directory.new(path))
  }

  Result.Ok(map)
}

fn run -> Result[Nil, String] {
  let opts = Options.new('wobsite')

  # TODO: allow serving files from a specific directory directly, without the
  # use of virtual hosts (e.g. to more easily serve/share local files).
  opts.flag('h', 'help', 'Show this help message')
  opts.single('', 'sites', 'DIR', 'The directory containing the websites')
  opts.single('', 'tls', 'DIR', 'The directory containing TLS configuration')
  opts.single('', 'port', 'PORT', 'A custom port to listen on')

  let matches = try opts.parse(env.arguments).map_error(fn (e) { e.to_string })

  if matches.contains?('help') {
    let _ = Stdout.new.print(opts.to_string)

    return Result.Ok(nil)
  }

  let sites_dir = recover try expand(matches.value('sites').or(SITES).to_path)
  let tls_dir = match matches.value('tls') {
    case Some(v) -> Option.Some(try expand(v.to_path))
    case _ -> Option.None
  }
  let port = matches
    .value('port')
    .then(fn (v) { Int.parse(v, int.Format.Decimal) })
    .or(PORT)
  let hosts = Hosts.new(sites_dir)
  let hosts_conf = await hosts.get
  let config_ver = AtomicInt.new(0)
  let logger = Logger.new
  let srv = Server.new(fn move {
    recover {
      Handler(
        hosts: hosts,
        hosts_map: hosts_conf.clone,
        config_version: ConfigVersion.new(config_ver),
        logger: logger.clone,
      )
    }
  })

  match tls_dir {
    case Some(dir) -> {
      let mut tls_conf = try load_tls(dir)
      let conf_state = ConfigVersion.new(config_ver)

      srv.dynamic_tls(fn move (host) {
        if conf_state.reload? {
          let _ = Stdout.new.print('reloading TLS configuration')

          match load_tls(dir) {
            case Ok(v) -> tls_conf = v
            case Error(e) -> {
              Stderr.new.print('failed to reload the TLS configuration: ${e}')
            }
          }
        }

        let Some(host) = host else return Option.None
        let Ok(conf) = tls_conf.get(host) else return Option.None

        Option.Some(conf)
      })
    }
    case _ -> {}
  }

  srv.before_start(fn (addr, _) { Stdout.new.print('listening on ${addr}') })

  Reloader().wait(config_ver, hosts)

  match srv.start(port) {
    case Ok(_) -> {}
    case Error(e) -> error('the server failed: ${e}')
  }

  Result.Ok(nil)
}

type async Hosts {
  let @path: Path
  let mut @config: Map[Slice[String], Directory]

  fn static new(path: uni Path) -> Self {
    let proc = Self(config: recover Map.new, path: path)

    proc.reload
    proc
  }

  fn async mut reload {
    match load_sites(@path) {
      case Ok(v) -> @config = v
      case Error(e) -> {
        Stderr.new.print('failed to load the configuration: ${e}')
      }
    }
  }

  fn async get(promise: uni Promise[Map[Slice[String], Directory]]) {
    promise.set(recover @config.clone)
  }
}

type async Reloader {
  fn async wait(version: AtomicInt, hosts: Hosts) {
    loop {
      Signal.Hangup.wait
      hosts.reload
      version.add(1)
    }
  }
}

type ConfigVersion {
  let @global: AtomicInt
  let mut @local: Int

  fn static new(global: AtomicInt) -> Self {
    Self(global: global, local: global.load)
  }

  fn mut reload? -> Bool {
    let global = @global.load

    if global == @local {
      false
    } else {
      @local = global
      true
    }
  }
}

type async Main {
  fn async main {
    match run {
      case Ok(_) -> {}
      case Error(e) -> error(e)
    }
  }
}

type Handler {
  let @hosts: Hosts
  let mut @hosts_map: Map[Slice[String], Directory]
  let @config_version: ConfigVersion
  let @logger: Logger

  fn mut reload_config {
    if @config_version.reload? { @hosts_map = await @hosts.get }
  }

  fn static_file(request: mut Request) -> Response {
    let (host, _) = request.host
    let Ok(dir) = @hosts_map.get(host) else return Response.bad_request
    let mut res = dir.handle(request, request.path.to_slice)

    if res.status.not_found? {
      match dir.path.join_strict('404.html') {
        case Some(v) -> res = dir.file(request, v).status(Status.not_found)
        case _ -> {}
      }
    }

    res.header(Header.access_control_allow_origin, '*')
  }

  fn bad_bot?(request: ref Request) -> Bool {
    # If a client can't be bothered identifying themselves, they're almost
    # certainly a bad bot.
    let ua = match request.headers.get(Header.user_agent) {
      case Ok(v) if v.size > 0 -> v
      case _ -> return true
    }

    # Real browsers these days send the Sec-Fetch-Site header, except for
    # Firefox when reloading a page in reader mode. This check should hopefully
    # catch clients pretending to be browsers when they're clearly not.
    #
    # Googlebot (and possibly other search crawlers) also starts its UA with
    # "Mozilla" but doesn't pass these headers, but does include a URL. We allow
    # such cases because at least the client gives us something to be identified
    # with.
    if
      ua.starts_with?('Mozilla')
        and !ua.contains?('://')
        and request.headers.get(Header.sec_fetch_site).error?
        and request.headers.get(Header.new('sec-gpc')).error?
    {
      return true
    }

    # We're serving static files and not PHP scripts, so clients requesting
    # those are likely bots scanning for vulnerabilities.
    match request.target.last {
      case Some(v) if v.ends_with?('.php') -> return true
      case _ -> {}
    }

    false
  }
}

impl Handle for Handler {
  fn pub mut handle(request: mut Request) -> Response {
    reload_config

    match request.method {
      case Get or Head -> {}
      case _ -> return Response.only_allow([Get, Head])
    }

    # This is just a simple heuristic for blocking clients that are just
    # painfully obvious useless bots.
    if bad_bot?(request) { return Response.forbidden }

    compress_response(request, static_file(request))
  }

  fn pub mut response(request: mut Request, response: Response) -> Response {
    @logger.log(request, response)
    response
  }
}
