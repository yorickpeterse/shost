import shost.config (Config, Sites, Version)
import std.bytes (Slice)
import std.json (Json)
import std.net.http (Header, Status)
import std.net.http.server (
  Directory, Get, Handle, Head, Logger, Request, Response, Server,
  compress_response,
)
import std.signal (Signal)
import std.stdio (Stderr)
import std.sync (Promise)
import std.uri (Host, Scheme)

fn new_logger(config: ref Config) -> Logger {
  if config.log_requests and config.log_timestamps {
    Logger.new
  } else if config.log_requests {
    Logger.new.without_timestamps
  } else {
    Logger.new.disabled
  }
}

fn start(config: Config) -> Result[Nil, String] {
  let debug = DebugWriter.new
  let sites = try config.sites.load
  let hosts = Hosts.new(recover config.sites.clone, recover sites.clone)
  let logger = new_logger(config)
  let ver = Version.new
  let ip = config.ip
  let port = config.port
  let tls = config.tls.some?
  let srv = {
    let ver = ver.clone
    let log = config.log_bad_bots

    Server.new(fn move {
      recover {
        let debug = if log { Option.Some(debug) } else { Option.None }

        Handler(
          debug: debug,
          port: port,
          tls: tls,
          hosts: hosts,
          sites: sites.clone,
          version: ver.clone,
          logger: logger.clone,
        )
      }
    })
  }

  match try config.load_tls {
    case Some(tls) -> {
      let mut tls = tls
      let ver = ver.clone

      srv.dynamic_tls(fn move (host) {
        if ver.updated? {
          # If reloading the TLS configuration fails we'll keep using the
          # existing so we don't just start dropping connections.
          match config.load_tls {
            case Ok(Some(v)) -> tls = v
            case Ok(_) -> {}
            case Error(e) -> debug.print(e.to_string)
          }
        }

        let Some(host) = host else return Option.None

        tls.get(host).ok
      })
    }
    case _ -> {}
  }

  Reloader().wait(recover ver.clone, hosts)
  srv.before_start(fn (addr, _) { debug.print('listening on ${addr}') })

  match srv.start_ip(ip, port) {
    case Ok(_) -> Result.Ok(nil)
    case Error(e) -> Result.Error('the server failed: ${e}')
  }
}

type async DebugWriter {
  let @writer: Stderr

  fn static new -> Self {
    Self(writer: recover Stderr.new)
  }

  fn async mut print(message: String) {
    @writer.print(message)
  }
}

# A process used for reloading the hosts configuration and propagating it across
# active connections.
#
# When the configuration needs to be refreshed we don't want thousands/tens of
# thousands of active connections to start hitting the file system. In addition,
# if there's an error with the new configuration we only want a single message
# printed instead of many.
#
# To ensure this is the case, the `Hosts` process is in charge of loading the
# list of new websites to serve. Active connections may then request a copy of
# this data when necessary.
type async Hosts {
  # The path to the directory containing the websites to serve.
  let @path: Sites

  # The currently enabled websites.
  let mut @sites: Map[Slice[String], Directory]

  fn static new(
    path: uni Sites,
    sites: uni Map[Slice[String], Directory],
  ) -> Self {
    Self(path: path, sites: sites)
  }

  fn async mut reload {
    # The list of sites is obtained through a simple directory listing. If this
    # fails it means the directory either doesn't exist or we don't have
    # permissions to access it, in which case existing requests will start
    # failing also.
    #
    # To detect such cases, we panic loudly instead of just printing a warning
    # that will likely just be lost in the sea of logs.
    @sites = @path.load.or_panic
  }

  fn async get(promise: uni Promise[Map[Slice[String], Directory]]) {
    promise.set(recover @sites.clone)
  }
}

# A process that waits for the SIGHUP signal and triggers a configuration reload
# in response.
type async Reloader {
  fn async wait(version: uni Version, hosts: Hosts) {
    loop {
      Signal.Hangup.wait
      hosts.reload
      version.update
    }
  }
}

# A type for handling requests, created for each HTTP connection.
type inline Handler {
  # The process to use for reloading the list of enabled websites.
  let @hosts: Hosts

  # The port we're listening on.
  let @port: Int

  # If TLS is used or not.
  let @tls: Bool

  # The mapping of hostnames to a `Directory` used to serve corresponding
  # requests.
  let @sites: Map[Slice[String], Directory]

  # The configuration version this connection is using.
  let @version: Version
  let @logger: Logger
  let @debug: Option[DebugWriter]

  fn mut reload_config {
    if @version.updated? {
      @sites.clear
      @sites.merge(await @hosts.get)
    }
  }

  fn static_file(request: mut Request) -> Response {
    let (host, _) = request.host
    let Ok(dir) = @sites.get(host) else return invalid_host(request, host)
    let mut res = dir.handle(request, request.path.to_slice)

    if res.status.not_found? {
      match dir.path.join_strict('404.html') {
        case Some(v) -> res = dir.file(request, v).status(Status.not_found)
        case _ -> {}
      }
    }

    res.header(Header.access_control_allow_origin, '*')
  }

  fn invalid_host(request: ref Request, host: Slice[String]) -> Response {
    let non_www = match host.strip_prefix('www.') {
      case Some(v) if @sites.get(v).ok? -> v
      case _ -> return Response.bad_request
    }

    let uri = request.uri.clone

    uri.host = Host.new(non_www)
    uri.scheme = Option.Some(if @tls { Scheme.Https } else { Scheme.Http })
    uri.port = Option.Some(@port)
    Response.new.status(Status.new(301)).header(Header.location, uri.to_string)
  }

  fn bad_bot?(request: ref Request) -> Bool {
    # If a client can't be bothered identifying themselves, they're almost
    # certainly a bad bot.
    let ua = match request.headers.get(Header.user_agent) {
      case Ok(v) if v.size > 0 -> v
      case _ -> return true
    }

    # Some bad bots pretend to be a Let's Encrypt validation server while
    # sending request to random paths.
    if ua.contains?('letsencrypt') {
      match request.target {
        case ['.well-known', 'acme-challenge', _] -> return false
        case _ -> return true
      }
    }

    # We're serving static files and not PHP scripts, so clients requesting
    # those are likely bots scanning for vulnerabilities.
    match request.target.last {
      case Some(v) if v.ends_with?('.php') -> return true
      case _ -> {}
    }

    # Real browsers these days send the Sec-Fetch-Site header, except for
    # Firefox when reloading a page in reader mode. This check should hopefully
    # catch clients pretending to be browsers when they're clearly not.
    #
    # Googlebot (and possibly other search crawlers) also starts its UA with
    # "Mozilla" but doesn't pass these headers, but does include a URL. We allow
    # such cases because at least the client gives us something to be identified
    # with.
    if
      ua.starts_with?('Mozilla')
        and !ua.contains?('://')
        and request.headers.get(Header.sec_fetch_site).error?
        and request.headers.get(Header.new('sec-gpc')).error?
        and request.headers.get(Header.new('sec-ch-ua')).error?
    {
      # Some clients use browser-like user agents but don't send the above
      # headers. Two examples are Google PageSpeed and a variety of feed readers
      # (e.g. News Explorer).
      #
      # To reduce the chance of flaggin legitimate clients as bad bots, we allow
      # the request if they support Brotli. Most (obvious) bots seem to support
      # Brotli while every real browser today does support it.
      if request.accepted_encodings.any?(fn (v) { v.name.equals?('br') }) {
        return false
      }

      return true
    }

    false
  }

  fn log_bad_bot(request: ref Request) {
    let Some(debug) = @debug else return
    let (host, _) = request.host
    let mut headers = Json.object

    for key in request.headers.keys {
      match request.headers.value(key) {
        case Ok(Single(val)) -> headers = headers.string(key.to_string, val)
        case Ok(Multiple(vals)) -> {
          headers = headers.array(
            key.to_string,
            vals.iter.reduce(Json.array, fn (ary, val) { ary.string(val) }),
          )
        }
        case _ -> next
      }
    }

    let json = Json
      .object
      .string('address', request.address.to_string)
      .string('host', host.to_string)
      .string('uri', request.uri.to_string)
      .object('headers', headers)
      .into_string

    debug.print(json)
  }
}

impl Handle for Handler {
  fn pub mut handle(request: mut Request) -> Response {
    reload_config

    match request.method {
      case Get or Head -> {}
      case _ -> return Response.only_allow([Get, Head])
    }

    # This is just a simple heuristic for blocking clients that are just
    # painfully obvious useless bots.
    if bad_bot?(request) {
      log_bad_bot(request)
      return Response.forbidden.close
    }

    compress_response(request, static_file(request))
  }

  fn pub mut response(request: mut Request, response: Response) -> Response {
    @logger.log(request, response)
    response
  }
}
