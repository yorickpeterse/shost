import shost.config (Config, Sites, Version)
import std.bytes (Slice)
import std.fs.path (Path)
import std.io
import std.net.http (Header, Status)
import std.net.http.server (
  Directory, Get, Handle, Head, Logger, Request, Response, Server,
  compress_response,
)
import std.net.socket (Notifier, UnixServer)
import std.signal (Signal)
import std.stdio (Stderr)
import std.sync (Promise)

fn new_logger(config: ref Config) -> Logger {
  if config.log_requests and config.log_timestamps {
    Logger.new
  } else if config.log_requests {
    Logger.new.without_timestamps
  } else {
    Logger.new.disabled
  }
}

fn start(config: Config) -> Result[Nil, String] {
  let sites = try config.sites.load
  let hosts = Hosts.new(recover config.sites.clone, recover sites.clone)
  let logger = new_logger(config)
  let ver = Version.new
  let srv = {
    let ver = ver.clone

    Server.new(fn move {
      recover {
        Handler(
          hosts: hosts,
          sites: sites.clone,
          version: ver.clone,
          logger: logger.clone,
        )
      }
    })
  }

  let ip = config.ip
  let port = config.port

  Reloader.new(recover ver.clone, hosts).wait

  match config.control_socket {
    case Some(v) -> {
      let (ctl_proc, ctl_not) = try ControlSocket
        .new(recover v.clone, recover ver.clone, hosts)
        .map_error(fn (e) { 'failed to enable the control socket: ${e}' })

      ctl_proc.run
      srv.before_shutdown(fn move { ctl_not.notify })
    }
    case _ -> {}
  }

  match try config.load_tls {
    case Some(tls) -> {
      let mut tls = tls
      let ver = ver.clone

      srv.dynamic_tls(fn move (host) {
        if ver.updated? {
          # If reloading the TLS configuration fails we'll keep using the
          # existing so we don't just start dropping connections.
          match config.load_tls {
            case Ok(Some(v)) -> tls = v
            case Ok(_) -> {}
            case Error(e) -> Stderr.new.print(e.to_string)
          }
        }

        let Some(host) = host else return Option.None

        tls.get(host).ok
      })
    }
    case _ -> {}
  }

  srv.before_start(fn (addr, _) { Stderr.new.print('listening on ${addr}') })

  match srv.start_ip(ip, port) {
    case Ok(_) -> Result.Ok(nil)
    case Error(e) -> Result.Error('the server failed: ${e}')
  }
}

fn reload(version: ref Version, hosts: Hosts) {
  hosts.reload
  version.update
}

# A process that listens on a Unix socket and is used to control the server
# (e.g. triggering configuration reloads).
#
# When running in a container it may be difficult to reload the configuration
# using Unix signals if the process sending the signal also runs in a container.
# In such a case the socket may be mounted across containers and used instead.
type async ControlSocket {
  let @path: Path
  let @buffer: ByteArray
  let @socket: UnixServer
  let @version: Version
  let @hosts: Hosts

  fn static new(
    path: uni Path,
    version: uni Version,
    hosts: Hosts,
  ) -> Result[(Self, Notifier), io.Error] {
    let _ = path.remove_file
    let sock = recover try UnixServer.new(path.clone)
    let not = sock.notifier.get
    let proc = Self(
      path: path,
      buffer: recover ByteArray.new,
      socket: sock,
      version: version,
      hosts: hosts,
    )

    Result.Ok((proc, not))
  }

  fn async mut run {
    loop {
      let client = match @socket.accept {
        case Ok(v) -> v
        case Error(Interrupted) -> break
        case _ -> next
      }

      # While we could accept any input here to trigger a reload, we check for a
      # specific string just to prevent users from depending on _any_ input
      # being valid, and so that (if ever necessary) we can add more commands in
      # the future.
      match client.read(into: @buffer, size: 6) {
        case Ok(_) if @buffer.equals?('reload') -> {
          reload(@version, @hosts)
          client.write('OK')
        }
        case _ -> client.write('invalid command')
      }

      @buffer.clear
    }

    let _ = @path.remove_file
  }
}

# A process used for reloading the hosts configuration and propagating it across
# active connections.
#
# When the configuration needs to be refreshed we don't want thousands/tens of
# thousands of active connections to start hitting the file system. In addition,
# if there's an error with the new configuration we only want a single message
# printed instead of many.
#
# To ensure this is the case, the `Hosts` process is in charge of loading the
# list of new websites to serve. Active connections may then request a copy of
# this data when necessary.
type async Hosts {
  # The path to the directory containing the websites to serve.
  let @path: Sites

  # The currently enabled websites.
  let mut @sites: Map[Slice[String], Directory]

  fn static new(
    path: uni Sites,
    sites: uni Map[Slice[String], Directory],
  ) -> Self {
    Self(path: path, sites: sites)
  }

  fn async mut reload {
    # The list of sites is obtained through a simple directory listing. If this
    # fails it means the directory either doesn't exist or we don't have
    # permissions to access it, in which case existing requests will start
    # failing also.
    #
    # To detect such cases, we panic loudly instead of just printing a warning
    # that will likely just be lost in the sea of logs.
    @sites = @path.load.or_panic
  }

  fn async get(promise: uni Promise[Map[Slice[String], Directory]]) {
    promise.set(recover @sites.clone)
  }
}

# A process that waits for the SIGHUP signal and triggers a configuration reload
# in response.
type async Reloader {
  let @version: Version
  let @hosts: Hosts

  fn static new(version: uni Version, hosts: Hosts) -> Self {
    Self(version: version, hosts: hosts)
  }

  fn async wait {
    loop {
      Signal.Hangup.wait
      reload(@version, @hosts)
    }
  }
}

# A type for handling requests, created for each HTTP connection.
type inline Handler {
  # The process to use for reloading the list of enabled websites.
  let @hosts: Hosts

  # The mapping of hostnames to a `Directory` used to serve corresponding
  # requests.
  let @sites: Map[Slice[String], Directory]

  # The configuration version this connection is using.
  let @version: Version
  let @logger: Logger

  fn mut reload_config {
    if @version.updated? {
      @sites.clear
      @sites.merge(await @hosts.get)
    }
  }

  fn static_file(request: mut Request) -> Response {
    let (host, _) = request.host
    let Ok(dir) = @sites.get(host) else return Response.bad_request
    let mut res = dir.handle(request, request.path.to_slice)

    if res.status.not_found? {
      match dir.path.join_strict('404.html') {
        case Some(v) -> res = dir.file(request, v).status(Status.not_found)
        case _ -> {}
      }
    }

    res.header(Header.access_control_allow_origin, '*')
  }

  fn bad_bot?(request: ref Request) -> Bool {
    # If a client can't be bothered identifying themselves, they're almost
    # certainly a bad bot.
    let ua = match request.headers.get(Header.user_agent) {
      case Ok(v) if v.size > 0 -> v
      case _ -> return true
    }

    # Real browsers these days send the Sec-Fetch-Site header, except for
    # Firefox when reloading a page in reader mode. This check should hopefully
    # catch clients pretending to be browsers when they're clearly not.
    #
    # Googlebot (and possibly other search crawlers) also starts its UA with
    # "Mozilla" but doesn't pass these headers, but does include a URL. We allow
    # such cases because at least the client gives us something to be identified
    # with.
    if
      ua.starts_with?('Mozilla')
        and !ua.contains?('://')
        and request.headers.get(Header.sec_fetch_site).error?
        and request.headers.get(Header.new('sec-gpc')).error?
    {
      return true
    }

    # Some bad bots pretend to be a Let's Encrypt validation server while
    # sending request to random paths.
    if ua.contains?('letsencrypt') {
      match request.target {
        case ['.well-known', 'acme-challenge', _] -> return false
        case _ -> return true
      }
    }

    # We're serving static files and not PHP scripts, so clients requesting
    # those are likely bots scanning for vulnerabilities.
    match request.target.last {
      case Some(v) if v.ends_with?('.php') -> return true
      case _ -> {}
    }

    false
  }
}

impl Handle for Handler {
  fn pub mut handle(request: mut Request) -> Response {
    reload_config

    match request.method {
      case Get or Head -> {}
      case _ -> return Response.only_allow([Get, Head])
    }

    # This is just a simple heuristic for blocking clients that are just
    # painfully obvious useless bots.
    if bad_bot?(request) { return Response.forbidden }

    compress_response(request, static_file(request))
  }

  fn pub mut response(request: mut Request, response: Response) -> Response {
    @logger.log(request, response)
    response
  }
}
