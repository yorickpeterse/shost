import shost.config (Config)
import shost.http
import std.optparse (Options)
import std.stdio (Stderr, Stdout)
import std.string (ToString)
import std.sys (exit)

fn print[T: ToString](value: ref T) {
  Stdout.new.print(value.to_string)
}

fn error(value: String) -> Never {
  let out = Stderr.new
  let _ = out.print(
    if out.terminal? {
      '\e[31;1merror\e[0m: ${value}'
    } else {
      'error: ${value}'
    },
  )

  exit(1)
}

fn run(
  arguments: Array[String],
  variables: Map[String, String],
) -> Result[Nil, String] {
  let opts = Options.new('shost')

  opts.description = 'An HTTP server for self-hosting static websites.'
  opts.usage = '[OPTIONS]'

  opts.flag('h', 'help', 'Show this help message')
  opts.single('s', 'sites', 'DIR', 'The directory containing websites to serve')
  opts.single('t', 'tls', 'DIR', 'The directory containing TLS configuration')
  opts.single('p', 'port', 'PORT', 'The port to listen on')
  opts.single('i', 'ip', 'IP', 'The IP to bind to')
  opts.flag('q', 'quiet', 'Disables logging of requests')

  let matches = try opts.parse(arguments).map_error(fn (e) { e.to_string })

  if matches.contains?('help') {
    print(opts)
    return Result.Ok(nil)
  }

  let cfg = Config.new

  match matches.value('sites') {
    case Some(v) -> cfg.sites = v.to_path
    case _ -> {}
  }

  match matches.value('tls') {
    case Some(v) -> cfg.tls = v.to_path
    case _ -> {}
  }

  match matches.value('ip') {
    case Some(v) -> try cfg.parse_ip(v)
    case _ -> {}
  }

  match matches.value('port') {
    case Some(v) -> try cfg.parse_port(v)
    case _ -> {}
  }

  cfg.log_requests = !matches.contains?('quiet')

  # systemd already includes timestamps for each log entry, so if we know we're
  # running under systemd there's no reason to add our own.
  cfg.log_timestamps = variables.get('INVOCATION_ID').error?

  http.start(cfg)
}
