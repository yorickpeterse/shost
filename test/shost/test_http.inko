import helpers (fixtures, get_port, send_request, with_directory)
import shost.config (Config, Sites, Version)
import shost.http (ControlSocket, Handler, Hosts, start)
import std.env
import std.io
import std.net.http (Header, Status)
import std.net.http.server (Directory, Logger)
import std.net.http.test (RequestBuilder)
import std.net.socket (UnixClient)
import std.signal (Signal)
import std.sync (Promise)
import std.test (Tests)

fn sites -> uni Sites {
  recover Sites(fixtures.join('sites'))
}

fn handler -> Handler {
  let map = Map.new

  for host in ['localhost', 'example.com'] {
    map.set(host.to_slice, Directory.new(sites.path.join(host)))
  }

  Handler(
    hosts: Hosts.new(path: sites, sites: recover map.clone),
    sites: map,
    version: Version.new,
    logger: Logger.new.disabled,
  )
}

impl ControlSocket {
  fn async wait(promise: uni Promise[Nil]) {
    promise.set(nil)
  }
}

fn pub tests(t: mut Tests) {
  t.fork(
    'http.start with TLS enabled',
    child: fn {
      let cfg = Config.new

      cfg.sites = fixtures.join('sites')
      cfg.tls = fixtures.join('tls')
      cfg.port = 0
      cfg.log_requests = true
      start(cfg)
    },
    test: fn (t, p) {
      let child = p.spawn_only.or_panic
      let port = get_port(child)

      t.true(send_request('https://localhost:${port}'))

      let out = ByteArray.new
      let _ = child.signal(Signal.Quit)

      t.true(child.wait.ok?)
      t.true(child.stdout.as_mut.get.read_all(out).ok?)
      t.true(out.to_string.contains?('GET /'))
    },
  )

  # It's difficult to accurately test the reloading of a config with this style
  # of integration test, at least without test-specific modifications to the
  # source code. Instead we use this as a simple smoke test.
  t.fork(
    'http.start with a config reload',
    child: fn {
      let cfg = Config.new

      cfg.sites = fixtures.join('sites')
      cfg.port = 0
      cfg.log_requests = true
      start(cfg)
    },
    test: fn (t, p) {
      let child = p.spawn_only.or_panic
      let port = get_port(child)
      let uri = 'http://localhost:${port}'

      # The initial request.
      t.true(send_request(uri))

      let _ = child.signal(Signal.Hangup)

      # The request that should process the config update.
      t.true(send_request(uri))

      let out = ByteArray.new
      let _ = child.signal(Signal.Quit)

      t.true(child.wait.ok?)
      t.true(child.stdout.as_mut.get.read_all(out).ok?)
      t.true(out.to_string.contains?('GET /'))
    },
  )

  t.fork(
    'http.start with a control socket',
    child: fn {
      let cfg = Config.new

      cfg.sites = fixtures.join('sites')
      cfg.port = 0
      cfg.log_requests = true
      cfg.control_socket = env.temporary_directory.join(
        'shost_http_start_control_socket.sock',
      )
      start(cfg)
    },
    test: fn (t, p) {
      let child = p.spawn_only.or_panic
      let port = get_port(child)
      let uri = 'http://localhost:${port}'
      let path = env.temporary_directory.join(
        'shost_http_start_control_socket.sock',
      )

      # The initial request, used to wait for the server to start.
      t.true(send_request(uri))
      t.true(path.exists?)

      let _ = child.signal(Signal.Quit)

      t.true(child.wait.ok?)

      # In case the child didn't remove the socket path.
      let _ = path.remove_file
    },
  )

  t.test('ControlSocket.new', fn (t) {
    with_directory(t.id, fn (dir) {
      let path = recover dir.join('shost.sock')
      let ver = Version.new
      let hosts = Hosts.new(path: sites, sites: recover Map.new)

      t.equal(
        ControlSocket.new(path, recover ver.clone, hosts).error,
        Option.None,
      )
    })
  })

  t.ok('ControlSocket.run with a valid command', fn (t) {
    with_directory(t.id, fn (dir) -> Result[Nil, io.Error] {
      let path = dir.join('shost.sock')
      let ver = Version.new
      let hosts = Hosts.new(path: sites, sites: recover Map.new)
      let (proc, not) = try ControlSocket.new(
        recover path.clone,
        recover ver.clone,
        hosts,
      )

      proc.run

      let client = try UnixClient.new(path)
      let buf = ByteArray.new

      try client.write('reload')
      try client.read_all(buf)

      t.equal(buf.to_string, 'OK')
      t.equal(ver.global.load, 1)
      t.equal((await hosts.get).size, 2)

      not.notify
      await proc.wait
      t.false(path.exists?)

      Result.Ok(nil)
    })
  })

  t.ok('ControlSocket.run with a invalid command', fn (t) {
    with_directory(t.id, fn (dir) -> Result[Nil, io.Error] {
      let path = dir.join('shost.sock')
      let ver = Version.new
      let hosts = Hosts.new(path: sites, sites: recover Map.new)
      let (proc, not) = try ControlSocket.new(
        recover path.clone,
        recover ver.clone,
        hosts,
      )

      proc.run

      let client = try UnixClient.new(path)
      let buf = ByteArray.new

      try client.write('foo')
      try client.read_all(buf)

      t.equal(buf.to_string, 'invalid command')
      t.equal(ver.global.load, 0)
      t.equal((await hosts.get).size, 0)

      not.notify
      Result.Ok(nil)
    })
  })

  t.test('Hosts.reload', fn (t) {
    let hosts = Hosts.new(path: sites, sites: recover Map.new)

    hosts.reload

    let map = recover await hosts.get

    t.true(map.get('localhost'.to_slice).ok?)
  })

  t.panic('Hosts.reload with an invalid path', fn {
    let hosts = Hosts.new(
      path: recover Sites(fixtures.join('invalid')),
      sites: recover Map.new,
    )

    hosts.reload
    await hosts.get
  })

  t.test('Handler.handle with an invalid method', fn (t) {
    let srv = handler
    let res = RequestBuilder.post('/').send(srv)

    t.equal(res.status, Status.method_not_allowed)
  })

  t.test('Handler.handle with a valid GET request', fn (t) {
    let srv = handler
    let res = RequestBuilder.get('/').send(srv)
    let buf = ByteArray.new

    t.equal(res.status, Status.ok)
    t.equal(res.headers.get(Header.access_control_allow_origin), Result.Ok('*'))
    t.equal(res.body.reader.read_all(buf), Result.Ok(6))
    t.equal(buf.to_string, 'hello\n')
  })

  t.test('Handler.handle with a valid HEAD request', fn (t) {
    let srv = handler
    let res = RequestBuilder.head('/').send(srv)
    let buf = ByteArray.new

    t.equal(res.status, Status.ok)
    t.equal(res.body.reader.read_all(buf), Result.Ok(0))
    t.equal(buf.to_string, '')
  })

  t.test('Handler.handle with a request to a non-existing file', fn (t) {
    let srv = handler
    let res = RequestBuilder.get('/missing').send(srv)
    let buf = ByteArray.new

    t.equal(res.status, Status.not_found)
    t.equal(res.body.reader.read_all(buf), Result.Ok(0))
  })

  t.test('Handler.handle with a custom 404 page', fn (t) {
    let srv = handler
    let req = RequestBuilder.get('/missing')

    req.headers.set(Header.host, 'example.com')

    let res = req.send(srv)
    let buf = ByteArray.new

    t.equal(res.status, Status.not_found)
    t.equal(res.body.reader.read_all(buf), Result.Ok(10))
    t.equal(buf.to_string, 'not found\n')
  })

  t.test('Handler.handle with a compressed response', fn (t) {
    let srv = handler
    let res = RequestBuilder
      .get('/')
      .header(Header.accept_encoding, 'gzip')
      .send(srv)

    t.equal(res.status, Status.ok)
    t.equal(res.headers.get(Header.content_encoding), Result.Ok('gzip'))
    t.true(
      match res.body {
        case Stream(_) -> true
        case _ -> false
      },
    )
  })

  t.test('Handler.handle with an empty User-agent', fn (t) {
    let srv = handler
    let req = RequestBuilder.get('/')

    req.headers.set(Header.user_agent, '')

    let res = req.send(srv)

    t.equal(res.status, Status.forbidden)
  })

  t.test('Handler.handle with an invalid browser-like User-agent', fn (t) {
    let srv = handler
    let req = RequestBuilder.get('/')

    req.headers.set(Header.user_agent, 'Mozilla/5.0 (Whatever)')

    let res = req.send(srv)

    t.equal(res.status, Status.forbidden)
  })

  t.test(
    'Handler.handle with a browser-like User-agent and the Sec-Fetch-Site header',
    fn (t) {
      let srv = handler
      let req = RequestBuilder.get('/')

      req.headers.set(Header.user_agent, 'Mozilla/5.0 (Whatever)')
      req.headers.set(Header.sec_fetch_site, 'origin')

      let res = req.send(srv)

      t.equal(res.status, Status.ok)
    },
  )

  t.test(
    'Handler.handle with a browser-like User-agent and the Sec-Gpc header',
    fn (t) {
      let srv = handler
      let req = RequestBuilder.get('/')

      req.headers.set(Header.user_agent, 'Mozilla/5.0 (Whatever)')
      req.headers.set(Header.new('sec-gpc'), 'foo')

      let res = req.send(srv)

      t.equal(res.status, Status.ok)
    },
  )

  t.test(
    'Handler.handle with a browser-like User-agent that includes a URL',
    fn (t) {
      let srv = handler
      let req = RequestBuilder.get('/')

      req.headers.set(
        Header.user_agent,
        'Mozilla/5.0 (Whatever; https://example.com)',
      )

      let res = req.send(srv)

      t.equal(res.status, Status.ok)
    },
  )

  t.test('Handler.handle with the Googlebot User-agent', fn (t) {
    let srv = handler
    let req = RequestBuilder.get('/')

    req.headers.set(
      Header.user_agent,
      'Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko; compatible; Googlebot/2.1; +http://www.google.com/bot.html) Chrome/1.2.3.4 Safari/537.36',
    )

    t.equal(req.send(srv).status, Status.ok)
  })

  t.test(
    "Handler.handle with a bot pretending to be a Let's Encrypt validation server",
    fn (t) {
      let srv = handler
      let req = RequestBuilder.get('/foo')

      req.headers.set(
        Header.user_agent,
        "Mozilla/5.0 (compatible; Let's Encrypt validation server; +https://www.letsencrypt.org)",
      )

      t.equal(req.send(srv).status, Status.forbidden)
    },
  )

  t.test(
    "Handler.handle with a valid Let's Encrypt HTTP-01 challenge",
    fn (t) {
      let srv = handler
      let req = RequestBuilder.get('/.well-known/acme-challenge/foo')

      req.headers.set(
        Header.user_agent,
        "Mozilla/5.0 (compatible; Let's Encrypt validation server; +https://www.letsencrypt.org)",
      )

      t.equal(req.send(srv).status, Status.not_found)
    },
  )

  t.test('Handler.handle with a request to a PHP file', fn (t) {
    let srv = handler
    let res = RequestBuilder.get('/wp-includes/test.php').send(srv)

    t.equal(res.status, Status.forbidden)
  })

  t.test('Handler.handle when the configuration needs to be reloaded', fn (t) {
    let srv = handler
    let _ = srv.sites.remove('example.com'.to_slice)
    let _ = srv.version.global.add(1)
    let req = RequestBuilder.get('/')

    req.headers.set(Header.host, 'example.com')

    let res = req.send(srv)
    let buf = ByteArray.new

    t.equal(res.status, Status.ok)
    t.equal(res.body.reader.read_all(buf), Result.Ok(8))
    t.equal(buf.to_string, 'example\n')
  })

  t.test('Handler.handle with an invalid host', fn (t) {
    let srv = handler
    let req = RequestBuilder.get('/')

    req.headers.set(Header.host, 'foo.com')

    let res = req.send(srv)

    t.equal(res.status, Status.bad_request)
  })
}
